# Genesis前推方案设计



## 背景：

每次计算totalOrder都需要从Genesis开始，随着交易数量的不断增加运算复杂度指数级增加会导致cpu和内存瓶颈的出现。因此，需要按照一定策略对历史数据进行清理。

## 设计思路：

StreamNet链上任意一个区块（含一笔交易）在经过“足够多”的证实之后就不会轻易发生改变，因此可以将已经固定的主链进行持久化，以后每一次计算全拓扑序时只需要将已经持久化的数据合并进来。

Genesis前推本质就是主链持久化之后将Genesis变更为新的值。

注: 当某一台交易量占51%的节点断网重连后会改变主链，此问题不在此方案讨论范围内。

## 设计方案：

### Genesis前推worker

该worker包含获取genesis和刷新dag graph两个方法。

#### 获取Genesis

该方法需要确保线程安全

+ 构建pivotChain

+ 获取dag中支链得分最高的交易节点的分数，得分最高的节点是被最多交易节点证实的节点。

+ 遍历pivot chain，当pivot chain上的节点得分大于支链最高得分与更新参数之和时，该主链节点即为新的Genesis。

+ 更新dag的Genesis节点队列，并保存

  以上步骤可以用如下图表进行说明：

  <待补充>

#### 刷新Dag

当上一步获取的Genesis与当前Genesis节点不一致时，以新的Genesis作为首节点更新dag。

+ 计算更新Genesis前的主链。
+ 构建临时dag graph
+ 计算更新Genesis后的主链；
+ 比较前后两条主链，将相同部分进行持久化。



## 名词解释

主链： 将dag上所有节点按照全拓扑序算法排列成为的一条链，该链包含所有的交易节点。

主链长度： 从Genesis节点开始计算，当Genesis发生变更后该长度是从新的Genesis节点开始计算。









